#include"Header_array implementation.h"

//=======================================================================================================================================
// Методы класса - Array 

//=======================================================================================================================================
//Конструкторы 

	// ctor по умолчнию
template <typename T>
Array<T>::Array () {
		size = 0; // присваиваем полю size ноль
		ptr = new T [1]; // выделяем память 
	}
	
	// ctor , который принимает размер массива 
template <typename T>
Array<T>::Array (int Size) {
		size = Size; // устанавливаем значение private переменной (size) нашего класса 
		ptr = new T [size]; // выделяем память 
		for ( int i=0 ; i < size ; i++) { 
			ptr[i] = 0; // обнуляем массив 
		}
	}
	
	// ctor копирования 
template <typename T>
Array<T>::Array ( const Array &other ) {
		size = other.size; // копируем размерность массива 
		ptr = new T [size]; // снова выделяем память 
		for ( int i=0 ; i < size ; i++ ) { 
			ptr[i] = other.ptr[i]; // присваиваем значения 
		}
	}
	
	// сtor перемещения
template <typename T>
Array<T>::Array ( Array &&other  ) { // сtor перемещения - этот конструтор нужен нам для того , чтобы возвращать значения конкатенации , без перезаписи и выделения памяти 
		size = other.size; // текущему объекту присваиваем значение размера объекта other 
		ptr = other.ptr; // теперь текущий объект и объект other указывают на одну и ту же область памяти 
		other.ptr = nullptr; // присваеваем указателю объекта other - nullptr , чтобы оператор delete[] - не мог стереть из него данные 
	}	// в результате , после конкатенации мы получаем наш объект , без повтороного выделния памяти , и лишнего копирования , а просто с помощью переноса значений из одного объекта в другой 
	
//=======================================================================================================================================
// Операторы 

	// оператор присваивания 
	template <typename T>
	Array<T> & Array<T>::operator = (const Array &other ) { 
	if(this == &other) // проверка , чтобы не произошло самоприсваивание 
		return *this;
	delete [] ptr; // удаляем "старый" массив 
	size = other.size; // определяем новую дину 
	ptr = new T [ size ]; // выделяем память 
	for ( int i=0 ; i < size ; i++ ) { 
			ptr[i] = other.ptr[i]; // присваиваем значения поэлементно 
		}
	return *this; // возврашаем разыменовый указатель на сам объект
	} 
	
	// оператор сравнения 
	template <typename T>
	bool Array<T>::operator == (const Array &other ) { 
		if ( size != other.size ) { // проверям размер массивов , если они не равны , тогда сразу возвращаем false 
			return 0;
		}
		
		for ( int i=0 ; i < size ; i++ ) {
			if ( ptr[i] != other.ptr[i]) // посимвольно проверям каждый элемент
				return 0;
			}
			
	return 1; // если массивы совпадают возвращаем true 
	}
	
	// оператор !=
	template <typename T>
	bool Array<T>::operator != (const Array &other ) { return !( operator ==(other)); }; // возвращаем инвертированый результат оператора ==
		
	// оператор для объединения массивов 
	template <typename T>
	Array<T> Array<T>::operator+ (const Array &other ) { 
		
		Array <T>result( size + other.size ); // новый объект , который вернёт наша функция , как результат работы метода 
		
		int i = 0; // тут нам нужно вынести итератор вне цикла , чтобы при записи второго слова в нашу строку - произошло добавление , а не перезапись слова 
		for ( ; i < size ; i++ ) {
			result.ptr[i] = ptr[i]; // записываем первое слово 
		}
		for (int j = 0 ; j < other.size ; j++ , i++ ) {
			result.ptr[i] = other.ptr[j]; // а тут второе  
		}
		
		return result; // возврашаем наш новый объект
	}

//=======================================================================================================================================
// Методы 
		
	// функция установки /  изменения элементов массива 
	template <typename T>
	void Array<T>::SetArray () {
		for ( int i=0 ; i < size ; i++ ) { 
			cin >> ptr[i] ; // посимвольно вводим значения элементов 
		}
	}
	
	// функция заполнения массива рандомными числами , в интервале от 1 до 10 ( чтобы не вводить с клавиатуры каждый раз )
	template <typename T>
	void Array<T>::SetRandom () {
		for ( int i=0 ; i < size ; i++ ) { 
			ptr[i] = rand() % 10 ;
		}
	}

	// Поиск по ключу
	template <typename T>
	int Array<T>::Finder ( const T key ) {
		for ( int i=0 ; i < size ; i++ ) {
			if (key == ptr[i])
				return i; // если нашли элемент - тогда возвращаем его индекс 
		}
		return -1; // если не нашли , возвращаем несуществующий индекс
	}
	
	// функция , которая переворачивает массив 
	template <typename T>
	Array<T> Array<T>::Reverse () { // функция , которая "переворачивает" массив 
		Array<T> result(size); // временная переменная 
    	result = *this; // в перемуню result , сохраняем старый массив 
 
    	delete [] ptr; // удаляем старые данные 
    	ptr = new T [size]; // выделяем новую память 
 
    	for (int i = 0; i < size ; i++ ) {
        	ptr[i] = result.ptr[size-1-i]; // присваиваем значения
    	}
 
    	return *this;  
	}
	
	// функция , которая удаляет элемент по его индексу
	template <typename T>
	void Array<T>::Delete_Array () {
		cout << " Пожалуйста , введите индекс элемента , который хотели-бы удалить - " ;
		unsigned int index;
		cin >> index;
		try {
			if ( index < 0 || index >= size ) 
				throw "Такого индекса не существует в массиве :( " ; // если происходит обращение к несуществующему индексу - бросаем исключение 
			Array<T> tmp(size); // создаем временый объект 
			tmp = *this; // копируем туда наш текущий объект 
		
			delete[] ptr; // удаляем данные текущего объекта 
			ptr = new T [size--]; // выделяем новую память , но на один элемент меньше 
		
			for (int i=0 ; i < index ; i++) {
				ptr[i] = tmp[i]; // записываем данные до index 
			}
		
			int smt = index; // сохраняем значниие переменной index , в перемненую smt , чтобы не потерять исходное значние index , во время итреаций по циклу 
			for (int i=index+1 ; i < tmp.size ; i++ ) {
				ptr[smt] = tmp[i];
				smt++;
			}
			cout << " - Элемент , под индексом [ " << index << " ]  , был удалён " << endl;
			cout << " Новый объект : " << *this ; // выводим новый объект 
	}
		catch ( const char* exception  ) { // ловим исключение 
			cout << " - Результат : "<< exception << endl; // выводим на экран 
		}
	}
	
	// функция , которая добавляет элемент по его индексу
	template <typename T>
	void Array<T>::Add_Array () {
		cout << " Пожалуйста , введите индекс , по которому вы хотите вставить новый элемент - " ;
		unsigned int index;
		cin >> index;
		try {
			if ( index < 0 || index >= size ) 
					throw "Такого индекса не существует в массиве :( " ; // если происходит обращение к несуществующему индексу - бросаем исключение 
			cout << " Пожалуйста , введите значение элемента , который , вы хотите вставить - " ;
			T variable;
			cin >> variable; // вводим значение нового элемента 
		
			Array<T> tmp(size); // создаем временый объект 
			tmp = *this; // копируем данные текущего объекта 
		
			delete[] ptr; // удаляем данные текущего объекта 
			ptr = new T [size++]; // снова выделяем память , на на один элемент больше 
		
			for (int i=0 ; i < index ; i++) {  // копируем все значение до index 
				ptr[i] = tmp[i];
			}
		
			ptr[index] = variable; // записываем новый элемент 
			int smt = index; // сохраняем значниие переменной index , в перемненую smt , чтобы не потерять исходное значние index , во время итреаций по циклу 
			for (int i=index+1 ; i < size ; i++ ) {
				ptr[i] = tmp[smt];
				smt ++;
			}
			cout << " - Элемент , под индексом [ " << index << " ]  , был вставлен " << endl;
			cout << " Новый объект : " << *this ; // выводим на экран новый объект 
		}
		catch ( const char* exception  ) { // ловим исключение 
			cout << " - Результат : "<< exception << endl; // выыводим исключение на экран 
		}
	}
	
//=======================================================================================================================================
// Дружественные функции 

	// дружественные функции класса Array ( вывода / ввода)
template <typename T> 
ostream& operator << ( ostream& os , const Array<T> & array ) { // вывод в поток 
	
	for ( int i=0 ; i < array.size ; i++ ) { // по символьно выводим элементы на экран
		os <<'\t'<<  array.ptr[i]  ;
	}
	os << endl;
	return os; 													  
	}
	
template <typename T>
istream& operator >> ( istream& is ,  Array<T>& array ) {   // ввод

	for ( int i=0 ; i < array.size ; i++ ) { 
		is >> array.ptr[i] ;
	}
    return is; 
	}
	
//=======================================================================================================================================
// Функция , которая переворачивает массив - Но работает со " встроеной структурой данных - массив " , ( а не с нашим собственым классом ) 

template <typename T>
T* Reverse ( T *arr , int size ) {   
	T *tmp = new T [size];
	for ( int i=0 ; i < size ; i++ ) {
		tmp[i] = arr[i];
	}

	delete[] arr;
	arr = new T [size];
	
	for ( int i = 0 ; i < size; i++ ) {
		arr[i] = tmp[size-1-i];
	}
    return arr;
	}
